(******************************************************************************
 * Featherweight-OCL --- A Formal Semantics for UML-OCL Version OCL 2.5
 *                       for the OMG Standard.
 *                       http://www.brucker.ch/projects/hol-testgen/
 *
 * This file is part of HOL-TestGen.
 *
 * Copyright (c) 2011-2018 UniversitÃ© Paris-Saclay, Univ. Paris-Sud, France
 *               2013-2017 IRT SystemX, France
 *               2011-2015 Achim D. Brucker, Germany
 *               2016-2018 The University of Sheffield, UK
 *               2016-2017 Nanyang Technological University, Singapore
 *               2017-2018 Virginia Tech, USA
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)

chapter{* Part ... *}

theory Gram_UML_Main
imports Gram_Transcendental
begin

print_syntax' (* UML_main *) remove Transcendental add any, args, cartouche_position, idt, id_position
prods:
  Fun.updbind = any[0] ":=" any[0] => "_updbind" (1000)
  Fun.updbinds = Fun.updbind[0] "," Fun.updbinds[0] => "_updbinds" (1000)
  Fun.updbinds = Fun.updbind[-1] (-1)
  HOL.case_syn = any[0] "=>" any[0] => "_case1" (10)
  HOL.case_syn = any[0] "\<Rightarrow>" any[0] => "_case1" (10)
  HOL.cases_syn = HOL.case_syn[0] "|" HOL.cases_syn[0] => "_case2" (1000)
  HOL.cases_syn = HOL.case_syn[-1] (-1)
  HOL.letbind = pttrn[0] "=" any[0] => "_bind" (10)
  HOL.letbinds = HOL.letbind[0] ";" HOL.letbinds[0] => "_binds" (1000)
  HOL.letbinds = HOL.letbind[-1] (-1)
  List.lc_qual = logic[0] => "_lc_test" (1000)
  List.lc_qual = any[0] "<-" logic[0] => "_lc_gen" (1000)
  List.lc_qual = any[0] "\<leftarrow>" logic[0] => "_lc_gen" (1000)
  List.lc_quals = "," List.lc_qual[0] List.lc_quals[0] => "_lc_quals" (1000)
  List.lc_quals = "]" => "_lc_end" (1000)
  List.lupdbind = any[0] ":=" any[0] => "_lupdbind" (1000)
  List.lupdbinds = List.lupdbind[0] "," List.lupdbinds[0] => "_lupdbinds" (1000)
  List.lupdbinds = List.lupdbind[-1] (-1)
  Map.maplet = any[0] "|->" any[0] => "_maplet" (1000)
  Map.maplet = any[0] "[|->]" any[0] => "_maplets" (1000)
  Map.maplet = any[0] "\<mapsto>" any[0] => "_maplet" (1000)
  Map.maplet = any[0] "[\<mapsto>]" any[0] => "_maplets" (1000)
  Map.maplets = Map.maplet[0] "," Map.maplets[0] => "_Maplets" (1000)
  Map.maplets = Map.maplet[-1] (-1)
  Product_Type.patterns = pttrn[0] "," Product_Type.patterns[0] => "_patterns" (1000)
  Product_Type.patterns = pttrn[-1] (-1)
  Product_Type.tuple_args = any[0] => "_tuple_arg" (1000)
  Product_Type.tuple_args = any[0] "," Product_Type.tuple_args[0] => "_tuple_args" (1000)
  Record.field = Record.ident[0] "=" any[0] => "_field" (1000)
  Record.field_type = Record.ident[0] "::" type[0] => "_field_type" (1000)
  Record.field_types = Record.field_type[0] "," Record.field_types[0] => "_field_types" (1000)
  Record.field_types = Record.field_type[-1] (-1)
  Record.field_update = Record.ident[0] ":=" any[0] => "_field_update" (1000)
  Record.field_updates = Record.field_update[0] "," Record.field_updates[0] => "_field_updates" (1000)
  Record.field_updates = Record.field_update[-1] (-1)
  Record.fields = Record.field[0] "," Record.fields[0] => "_fields" (1000)
  Record.fields = Record.field[-1] (-1)
  Record.ident = longid => "_constify" (1000)
  Record.ident = id => "_constify" (1000)
  any = prop'[-1] (-1)
  any = logic[-1] (-1)
  aprop = "_" => "\<^const>Pure.dummy_pattern" (1000)
  aprop = "XCONST" longid_position[0] => "_context_xconst" (1000)
  aprop = "XCONST" id_position[0] => "_context_xconst" (1000)
  aprop = "CONST" longid_position[0] => "_context_const" (1000)
  aprop = "CONST" id_position[0] => "_context_const" (1000)
  aprop = "\<dots>" => "_DDDOT" (1000)
  aprop = "(" aprop[0] ")" (1000)
  aprop = "..." => "_DDDOT" (1000)
  aprop = logic[1000] cargs[1000] => "_applC" (999)
  aprop = var_position[-1] (-1)
  aprop = longid_position[-1] (-1)
  aprop = id_position[-1] (-1)
  args = any[0] "," args[0] => "_args" (1000)
  args = any[-1] (-1)
  asms = "prop"[0] ";" asms[0] => "_asms" (1000)
  asms = "prop"[0] => "_asm" (1000)
  cargs = any[1000] cargs[1000] => "_cargs" (1000)
  cargs = any[-1] (-1)
  cartouche_position = cartouche => "_position" (1000)
  class_name = longid => "_class_name" (1000)
  class_name = id => "_class_name" (1000)
  classes = class_name[0] "," classes[0] => "_classes" (1000)
  classes = class_name[-1] (-1)
  float_const = float_position[0] => "_constify" (1000)
  float_position = float_token => "_position" (1000)
  id_position = id => "_position" (1000)
  idt = "(" idt[0] ")" (1000)
  idt = "_" "::" type[0] => "_idtypdummy" (0)
  idt = "_" => "_idtdummy" (1000)
  idt = id_position[0] "::" type[0] => "_idtyp" (0)
  idt = id_position[-1] (-1)
  idts = idt[1] idts[0] => "_idts" (0)
  idts = idt[-1] (-1)
  index = "\<index>" => "_indexvar" (1000)
  index = => "_indexdefault" (1000)
  index = "\<^bsub>" logic[0] "\<^esub>" => "_index" (1000)
  logic = "op" "&&&" => "\<^const>Pure.conjunction" (1000)
  logic = "op" "==>" => "\<^const>Pure.imp" (1000)
  logic = "op" "==" => "\<^const>Pure.eq" (1000)
  logic = "op" "\<Longrightarrow>" => "\<^const>Pure.imp" (1000)
  logic = "op" "\<equiv>" => "\<^const>Pure.eq" (1000)
  logic = "op" "\<longrightarrow>" => "\<^const>HOL.implies" (1000)
  logic = "op" "=" => "\<^const>HOL.eq" (1000)
  logic = "op" "\<and>" => "\<^const>HOL.conj" (1000)
  logic = "op" "\<or>" => "\<^const>HOL.disj" (1000)
  logic = "op" "\<noteq>" => "\<^const>HOL.not_equal" (1000)
  logic = "op" "~=" => "\<^const>HOL.not_equal" (1000)
  logic = "op" "-->" => "\<^const>HOL.implies" (1000)
  logic = "op" "|" => "\<^const>HOL.disj" (1000)
  logic = "op" "&" => "\<^const>HOL.conj" (1000)
  logic = "op" "\<longleftrightarrow>" => "\<^const>HOL.iff" (1000)
  logic = "op" "=simp=>" => "\<^const>HOL.simp_implies" (1000)
  logic = "op" "<" => "\<^const>Orderings.ord_class.less" (1000)
  logic = "op" "\<le>" => "\<^const>Orderings.ord_class.less_eq" (1000)
  logic = "op" "\<ge>" => "\<^const>Orderings.ord_class.greater_eq" (1000)
  logic = "op" ">" => "\<^const>Orderings.ord_class.greater" (1000)
  logic = "op" "<=" => "\<^const>Orderings.ord_class.less_eq" (1000)
  logic = "op" ">=" => "\<^const>Orderings.ord_class.greater_eq" (1000)
  logic = "op" "+" => "\<^const>Groups.plus_class.plus" (1000)
  logic = "op" "-" => "\<^const>Groups.minus_class.minus" (1000)
  logic = "op" "*" => "\<^const>Groups.times_class.times" (1000)
  logic = "op" "\<in>" => "\<^const>Set.member" (1000)
  logic = "op" "\<notin>" => "\<^const>Set.not_member" (1000)
  logic = "op" "~:" => "\<^const>Set.not_member" (1000)
  logic = "op" ":" => "\<^const>Set.member" (1000)
  logic = "op" "\<subseteq>" => "\<^const>Set.subset_eq" (1000)
  logic = "op" "\<subset>" => "\<^const>Set.subset" (1000)
  logic = "op" "\<supseteq>" => "\<^const>Set.supset_eq" (1000)
  logic = "op" "\<supset>" => "\<^const>Set.supset" (1000)
  logic = "op" "\<inter>" => "\<^const>Set.inter" (1000)
  logic = "op" "Int" => "\<^const>Set.inter" (1000)
  logic = "op" "\<union>" => "\<^const>Set.union" (1000)
  logic = "op" "Un" => "\<^const>Set.union" (1000)
  logic = "op" "`" => "\<^const>Set.image" (1000)
  logic = "op" "-`" => "\<^const>Set.vimage" (1000)
  logic = "op" "\<circ>" => "\<^const>Fun.comp" (1000)
  logic = "op" "o" => "\<^const>Fun.comp" (1000)
  logic = "op" "\<times>" => "\<^const>Product_Type.Times" (1000)
  logic = "op" "<+>" => "\<^const>Sum_Type.Plus" (1000)
  logic = "op" "dvd" => "\<^const>Rings.dvd_class.dvd" (1000)
  logic = "op" "div" => "\<^const>Rings.divide_class.divide" (1000)
  logic = "op" "/" => "\<^const>Fields.inverse_class.inverse_divide" (1000)
  logic = "op" "^^" => "\<^const>Nat.compower" (1000)
  logic = "op" "O" => "\<^const>Relation.relcomp" (1000)
  logic = "op" "OO" => "\<^const>Relation.relcompp" (1000)
  logic = "op" "``" => "\<^const>Relation.Image" (1000)
  logic = "op" "<*lex*>" => "\<^const>Wellfounded.lex_prod" (1000)
  logic = "op" "<*mlex*>" => "\<^const>Wellfounded.mlex_prod" (1000)
  logic = "op" "initial_segment_of" => "\<^const>Zorn.initialSegmentOf" (1000)
  logic = "op" "//" => "\<^const>Equiv_Relations.quotient" (1000)
  logic = "op" "respects" => "\<^const>Equiv_Relations.RESPECTS" (1000)
  logic = "op" "respects2" => "\<^const>Equiv_Relations.RESPECTS2" (1000)
  logic = "op" "^" => "\<^const>Power.power_class.power" (1000)
  logic = "op" "mod" => "\<^const>Divides.div_class.mod" (1000)
  logic = "op" "#" => "\<^const>List.list.Cons" (1000)
  logic = "op" "@" => "\<^const>List.append" (1000)
  logic = "op" "!" => "\<^const>List.nth" (1000)
  logic = "op" "\<circ>\<^sub>m" => "\<^const>Map.map_comp" (1000)
  logic = "op" "++" => "\<^const>Map.map_add" (1000)
  logic = "op" "|`" => "\<^const>Map.restrict_map" (1000)
  logic = "op" "\<subseteq>\<^sub>m" => "\<^const>Map.map_le" (1000)
  logic = "op" "\<times>\<^sub>F" => "\<^const>Filter.prod_filter" (1000)
  logic = "op" "\<longlongrightarrow>" => "\<^const>Topological_Spaces.topological_space_class.tendsto" (1000)
  logic = "op" "*\<^sub>R" => "\<^const>Real_Vector_Spaces.scaleR_class.scaleR" (1000)
  logic = "op" "/\<^sub>R" => "\<^const>Real_Vector_Spaces.scaleR_class.divideR" (1000)
  logic = "op" "sums" => "\<^const>Series.sums" (1000)
  logic = "op" "has_derivative" => "\<^const>Deriv.has_derivative" (1000)
  logic = "op" "has_field_derivative" => "\<^const>Deriv.has_field_derivative" (1000)
  logic = "op" "has_vector_derivative" => "\<^const>Deriv.has_vector_derivative" (1000)
  logic = "op" "differentiable" => "\<^const>Deriv.differentiable" (1000)
  logic = "op" "has_real_derivative" => "\<^const>Deriv.has_real_derivative" (1000)
  logic = "op" "choose" => "\<^const>Binomial.binomial" (1000)
  logic = "op" "gchoose" => "\<^const>Binomial.field_char_0_class.gbinomial" (1000)
  logic = "op" "powr" => "\<^const>Transcendental.powr" (1000)
  logic = "op" "\<triangleq>" => "\<^const>UML_Logic.StrongEq" (1000)
  logic = "op" "\<triangleq>\<^sub>p\<^sub>r\<^sub>e" => "\<^const>UML_Logic.StrongEq\<^sub>p\<^sub>r\<^sub>e" (1000)
  logic = "op" "\<triangleq>\<^sub>p\<^sub>o\<^sub>s\<^sub>t" => "\<^const>UML_Logic.StrongEq\<^sub>p\<^sub>o\<^sub>s\<^sub>t" (1000)
  logic = "op" "and" => "\<^const>UML_Logic.OclAnd" (1000)
  logic = "op" "or" => "\<^const>UML_Logic.OclOr" (1000)
  logic = "op" "implies" => "\<^const>UML_Logic.OclImplies" (1000)
  logic = "op" "\<doteq>" => "\<^const>UML_Logic.StrictRefEq" (1000)
  logic = "op" "<>" => "_notequal" (1000)
  logic = "op" "+\<^sub>i\<^sub>n\<^sub>t" => "\<^const>UML_Integer.OclAdd\<^sub>I\<^sub>n\<^sub>t\<^sub>e\<^sub>g\<^sub>e\<^sub>r" (1000)
  logic = "op" "-\<^sub>i\<^sub>n\<^sub>t" => "\<^const>UML_Integer.OclMinus\<^sub>I\<^sub>n\<^sub>t\<^sub>e\<^sub>g\<^sub>e\<^sub>r" (1000)
  logic = "op" "*\<^sub>i\<^sub>n\<^sub>t" => "\<^const>UML_Integer.OclMult\<^sub>I\<^sub>n\<^sub>t\<^sub>e\<^sub>g\<^sub>e\<^sub>r" (1000)
  logic = "op" "div\<^sub>i\<^sub>n\<^sub>t" => "\<^const>UML_Integer.OclDivision\<^sub>I\<^sub>n\<^sub>t\<^sub>e\<^sub>g\<^sub>e\<^sub>r" (1000)
  logic = "op" "mod\<^sub>i\<^sub>n\<^sub>t" => "\<^const>UML_Integer.OclModulus\<^sub>I\<^sub>n\<^sub>t\<^sub>e\<^sub>g\<^sub>e\<^sub>r" (1000)
  logic = "op" "<\<^sub>i\<^sub>n\<^sub>t" => "\<^const>UML_Integer.OclLess\<^sub>I\<^sub>n\<^sub>t\<^sub>e\<^sub>g\<^sub>e\<^sub>r" (1000)
  logic = "op" "\<le>\<^sub>i\<^sub>n\<^sub>t" => "\<^const>UML_Integer.OclLe\<^sub>I\<^sub>n\<^sub>t\<^sub>e\<^sub>g\<^sub>e\<^sub>r" (1000)
  logic = "op" "+\<^sub>s\<^sub>t\<^sub>r\<^sub>i\<^sub>n\<^sub>g" => "\<^const>UML_String.OclAdd\<^sub>S\<^sub>t\<^sub>r\<^sub>i\<^sub>n\<^sub>g" (1000)
  logic = "op" "+\<^sub>r\<^sub>e\<^sub>a\<^sub>l" => "\<^const>UML_Real.OclAdd\<^sub>R\<^sub>e\<^sub>a\<^sub>l" (1000)
  logic = "op" "-\<^sub>r\<^sub>e\<^sub>a\<^sub>l" => "\<^const>UML_Real.OclMinus\<^sub>R\<^sub>e\<^sub>a\<^sub>l" (1000)
  logic = "op" "*\<^sub>r\<^sub>e\<^sub>a\<^sub>l" => "\<^const>UML_Real.OclMult\<^sub>R\<^sub>e\<^sub>a\<^sub>l" (1000)
  logic = "op" "div\<^sub>r\<^sub>e\<^sub>a\<^sub>l" => "\<^const>UML_Real.OclDivision\<^sub>R\<^sub>e\<^sub>a\<^sub>l" (1000)
  logic = "op" "mod\<^sub>r\<^sub>e\<^sub>a\<^sub>l" => "\<^const>UML_Real.OclModulus\<^sub>R\<^sub>e\<^sub>a\<^sub>l" (1000)
  logic = "op" "<\<^sub>r\<^sub>e\<^sub>a\<^sub>l" => "\<^const>UML_Real.OclLess\<^sub>R\<^sub>e\<^sub>a\<^sub>l" (1000)
  logic = "op" "\<le>\<^sub>r\<^sub>e\<^sub>a\<^sub>l" => "\<^const>UML_Real.OclLe\<^sub>R\<^sub>e\<^sub>a\<^sub>l" (1000)
  logic = "op" "\<cong>" => "\<^const>UML_Bag.ApproxEq" (1000)
  logic = "XCONST" longid_position[0] => "_context_xconst" (1000)
  logic = "XCONST" id_position[0] => "_context_xconst" (1000)
  logic = "CONST" longid_position[0] => "_context_const" (1000)
  logic = "CONST" id_position[0] => "_context_const" (1000)
  logic = "\<dots>" => "_DDDOT" (1000)
  logic = "TYPE" "(" type[0] ")" => "_TYPE" (1000)
  logic = "\<lambda>" pttrns[0] "." any[3] => "_lambda" (3)
  logic = "\<lambda>" HOL.cases_syn[0] => "_lam_pats_syntax" (10)
  logic = "(" logic[0] ")" (1000)
  logic = "(" any[0] "," Product_Type.tuple_args[0] ")" => "_tuple" (1000)
  logic = "..." => "_DDDOT" (1000)
  logic = "%" pttrns[0] "." any[3] => "_lambda" (3)
  logic = "%" HOL.cases_syn[0] => "_lam_pats_syntax" (10)
  logic = "_" => "\<^const>Pure.dummy_pattern" (1000)
  logic = "\<forall>" idts[0] "." logic[10] => "\<^const>HOL.All_binder" (10)
  logic = "\<forall>" idt[0] "\<ge>" any[0] "." logic[10] => "_All_greater_eq" (10)
  logic = "\<forall>" idt[0] ">" any[0] "." logic[10] => "_All_greater" (10)
  logic = "\<forall>" idt[0] "\<le>" any[0] "." logic[10] => "_All_less_eq" (10)
  logic = "\<forall>" idt[0] "<" any[0] "." logic[10] => "_All_less" (10)
  logic = "\<forall>" pttrn[0] "\<in>" logic[0] "." logic[10] => "_Ball" (10)
  logic = "\<forall>" idt[0] "\<subseteq>" any[0] "." logic[10] => "_setleAll" (10)
  logic = "\<forall>" idt[0] "\<subset>" any[0] "." logic[10] => "_setlessAll" (10)
  logic = "\<exists>" idts[0] "." logic[10] => "\<^const>HOL.Ex_binder" (10)
  logic = "\<exists>" idt[0] "\<ge>" any[0] "." logic[10] => "_Ex_greater_eq" (10)
  logic = "\<exists>" idt[0] ">" any[0] "." logic[10] => "_Ex_greater" (10)
  logic = "\<exists>" idt[0] "\<le>" any[0] "." logic[10] => "_Ex_less_eq" (10)
  logic = "\<exists>" idt[0] "<" any[0] "." logic[10] => "_Ex_less" (10)
  logic = "\<exists>" pttrn[0] "\<in>" logic[0] "." logic[10] => "_Bex" (10)
  logic = "\<exists>" idt[0] "\<subseteq>" any[0] "." logic[10] => "_setleEx" (10)
  logic = "\<exists>" idt[0] "\<subset>" any[0] "." logic[10] => "_setlessEx" (10)
  logic = "\<not>" logic[40] => "\<^const>HOL.Not" (40)
  logic = "\<exists>!" idts[0] "." logic[10] => "\<^const>HOL.Ex1_binder" (10)
  logic = "\<exists>!" pttrn[0] "\<in>" logic[0] "." logic[10] => "_Bex1" (10)
  logic = "\<exists>!" idt[0] "\<subseteq>" any[0] "." logic[10] => "_setleEx1" (10)
  logic = "~" logic[40] => "\<^const>HOL.Not" (40)
  logic = "THE" pttrn[0] "." logic[10] => "_The" (10)
  logic = "let" HOL.letbinds[0] "in" any[10] => "_Let" (10)
  logic = "case" any[0] "of" HOL.cases_syn[0] => "_case_syntax" (10)
  logic = "EX!" idts[0] "." logic[10] => "\<^const>HOL.Ex1_binder" (10)
  logic = "EX!" pttrn[0] ":" logic[0] "." logic[10] => "_Bex1" (10)
  logic = "EX" idts[0] "." logic[10] => "\<^const>HOL.Ex_binder" (10)
  logic = "EX" idt[0] ">=" any[0] "." logic[10] => "_Ex_greater_eq" (10)
  logic = "EX" idt[0] ">" any[0] "." logic[10] => "_Ex_greater" (10)
  logic = "EX" idt[0] "<=" any[0] "." logic[10] => "_Ex_less_eq" (10)
  logic = "EX" idt[0] "<" any[0] "." logic[10] => "_Ex_less" (10)
  logic = "EX" pttrn[0] ":" logic[0] "." logic[10] => "_Bex" (10)
  logic = "ALL" idts[0] "." logic[10] => "\<^const>HOL.All_binder" (10)
  logic = "ALL" idt[0] ">=" any[0] "." logic[10] => "_All_greater_eq" (10)
  logic = "ALL" idt[0] ">" any[0] "." logic[10] => "_All_greater" (10)
  logic = "ALL" idt[0] "<=" any[0] "." logic[10] => "_All_less_eq" (10)
  logic = "ALL" idt[0] "<" any[0] "." logic[10] => "_All_less" (10)
  logic = "ALL" pttrn[0] ":" logic[0] "." logic[10] => "_Ball" (10)
  logic = "?!" idts[0] "." logic[10] => "\<^const>HOL.Ex1_binder" (10)
  logic = "?!" pttrn[0] ":" logic[0] "." logic[10] => "_Bex1" (10)
  logic = "?" idts[0] "." logic[10] => "\<^const>HOL.Ex_binder" (10)
  logic = "?" idt[0] "<=" any[0] "." logic[10] => "_Ex_less_eq" (10)
  logic = "?" idt[0] "<" any[0] "." logic[10] => "_Ex_less" (10)
  logic = "?" pttrn[0] ":" logic[0] "." logic[10] => "_Bex" (10)
  logic = "!" idts[0] "." logic[10] => "\<^const>HOL.All_binder" (10)
  logic = "!" idt[0] "<=" any[0] "." logic[10] => "_All_less_eq" (10)
  logic = "!" idt[0] "<" any[0] "." logic[10] => "_All_less" (10)
  logic = "!" pttrn[0] ":" logic[0] "." logic[10] => "_Ball" (10)
  logic = "if" logic[0] "then" any[0] "else" any[10] => "\<^const>HOL.If" (10)
  logic = "if" logic[10] "then" logic[10] "else" logic[10] "endif" => "\<^const>UML_Logic.OclIf" (50)
  logic = "LEAST" idts[0] "." logic[10] => "\<^const>Orderings.ord_class.Least_binder" (10)
  logic = "LEAST" id ":" logic[0] "." logic[10] => "_Bleast" (10)
  logic = "LEAST" id "\<in>" logic[0] "." logic[10] => "_Bleast" (10)
  logic = "LEAST" pttrn[0] "WRT" logic[4] "." logic[10] => "_LeastM" (10)
  logic = "0" => "\<^const>Groups.zero_class.zero" (1000)
  logic = "-" any[81] => "\<^const>Groups.uminus_class.uminus" (80)
  logic = "\<bar>" any[0] "\<bar>" => "\<^const>Groups.abs_class.abs" (1000)
  logic = "1" => "\<^const>Groups.one_class.one" (1000)
  logic = "{" pttrn[0] "." logic[0] "}" => "_Coll" (1000)
  logic = "{" pttrn[0] ":" logic[0] "." logic[0] "}" => "_Collect" (1000)
  logic = "{" pttrn[0] "\<in>" logic[0] "." logic[0] "}" => "_Collect" (1000)
  logic = "{" args[0] "}" => "_Finset" (1000)
  logic = "{" any[0] "|" idts[0] "." logic[0] "}" => "_Setcompr" (1000)
  logic = "{" any[0] "<..}" => "\<^const>Set_Interval.ord_class.greaterThan" (1000)
  logic = "{" any[0] "..}" => "\<^const>Set_Interval.ord_class.atLeast" (1000)
  logic = "{" any[0] "<..<" any[0] "}" => "\<^const>Set_Interval.ord_class.greaterThanLessThan" (1000)
  logic = "{" any[0] "..<" any[0] "}" => "\<^const>Set_Interval.ord_class.atLeastLessThan" (1000)
  logic = "{" any[0] "<.." any[0] "}" => "\<^const>Set_Interval.ord_class.greaterThanAtMost" (1000)
  logic = "{" any[0] ".." any[0] "}" => "\<^const>Set_Interval.ord_class.atLeastAtMost" (1000)
  logic = "{}" => "\<^const>Set.empty" (1000)
  logic = "SUP" pttrn[0] ":" logic[0] "." any[10] => "_SUP" (10)
  logic = "SUP" pttrns[0] "." any[10] => "_SUP1" (10)
  logic = "INF" pttrn[0] ":" logic[0] "." any[10] => "_INF" (10)
  logic = "INF" pttrns[0] "." any[10] => "_INF1" (10)
  logic = "\<Inter>" logic[900] => "\<^const>Complete_Lattices.Inter" (900)
  logic = "\<Inter>" pttrn[0] "\<in>" logic[0] "." logic[10] => "_INTER" (10)
  logic = "\<Inter>" pttrns[0] "." logic[10] => "_INTER1" (10)
  logic = "\<Inter>" any[0] "<" any[0] "." logic[10] => "_INTER_less" (10)
  logic = "\<Inter>" any[0] "\<le>" any[0] "." logic[10] => "_INTER_le" (10)
  logic = "INT" pttrn[0] ":" logic[0] "." logic[10] => "_INTER" (10)
  logic = "INT" pttrns[0] "." logic[10] => "_INTER1" (10)
  logic = "INT" any[0] "<" any[0] "." logic[10] => "_INTER_less" (10)
  logic = "INT" any[0] "<=" any[0] "." logic[10] => "_INTER_le" (10)
  logic = "\<Union>" logic[900] => "\<^const>Complete_Lattices.Union" (900)
  logic = "\<Union>" pttrn[0] "\<in>" logic[0] "." logic[10] => "_UNION" (10)
  logic = "\<Union>" pttrns[0] "." logic[10] => "_UNION1" (10)
  logic = "\<Union>" any[0] "<" any[0] "." logic[10] => "_UNION_less" (10)
  logic = "\<Union>" any[0] "\<le>" any[0] "." logic[10] => "_UNION_le" (10)
  logic = "UN" pttrn[0] ":" logic[0] "." logic[10] => "_UNION" (10)
  logic = "UN" pttrns[0] "." logic[10] => "_UNION1" (10)
  logic = "UN" any[0] "<" any[0] "." logic[10] => "_UNION_less" (10)
  logic = "UN" any[0] "<=" any[0] "." logic[10] => "_UNION_le" (10)
  logic = "()" => "\<^const>Product_Type.Unity" (1000)
  logic = "SIGMA" pttrn[0] ":" logic[0] "." logic[10] => "_Sigma" (10)
  logic = "\<nat>" => "\<^const>Nat.semiring_1_class.Nats" (1000)
  logic = "\<some>" pttrn[0] "." logic[10] => "_Eps" (10)
  logic = "@" pttrn[0] "." logic[10] => "_Eps" (10)
  logic = "SOME" pttrn[0] "." logic[10] => "_Eps" (10)
  logic = "GREATEST" idts[0] "." logic[10] => "\<^const>Hilbert_Choice.Greatest_binder" (10)
  logic = "GREATEST" pttrn[0] "WRT" logic[4] "." logic[10] => "_GreatestM" (10)
  logic = "chain\<^sub>\<subseteq>" => "\<^const>Zorn.chain_subset" (1000)
  logic = "CSUM" pttrn[0] ":" logic[51] "." logic[10] => "_Csum" (10)
  logic = num_const[0] => "_Numeral" (1000)
  logic = "\<Sum>" logic[1000] => "\<^const>Groups_Big.comm_monoid_add_class.Setsum" (999)
  logic = "\<Sum>" pttrn[0] "\<in>" logic[51] "." any[10] => "_setsum" (10)
  logic = "\<Sum>" pttrn[0] "|" logic[0] "." any[10] => "_qsetsum" (10)
  logic = "\<Sum>" idt[0] "\<le>" any[0] "." any[10] => "_upto_setsum" (10)
  logic = "\<Sum>" idt[0] "<" any[0] "." any[10] => "_upt_setsum" (10)
  logic = "\<Sum>" idt[0] "=" any[0] "..<" any[0] "." any[10] => "_from_upto_setsum" (10)
  logic = "\<Sum>" idt[0] "=" any[0] ".." any[0] "." any[10] => "_from_to_setsum" (10)
  logic = "\<Sum>" pttrn[0] "\<leftarrow>" logic[51] "." any[10] => "_listsum" (10)
  logic = "\<Sum>" idts[0] "." any[10] => "\<^const>Series.suminf_binder" (10)
  logic = "SUM" pttrn[0] ":" logic[51] "." any[10] => "_setsum" (10)
  logic = "SUM" pttrn[0] "|" logic[0] "." any[10] => "_qsetsum" (10)
  logic = "SUM" idt[0] "<=" any[0] "." any[10] => "_upto_setsum" (10)
  logic = "SUM" idt[0] "<" any[0] "." any[10] => "_upt_setsum" (10)
  logic = "SUM" idt[0] "=" any[0] "..<" any[0] "." any[10] => "_from_upto_setsum" (10)
  logic = "SUM" idt[0] "=" any[0] ".." any[0] "." any[10] => "_from_to_setsum" (10)
  logic = "SUM" pttrn[0] "<-" logic[51] "." any[10] => "_listsum" (10)
  logic = "\<Prod>" logic[1000] => "\<^const>Groups_Big.comm_monoid_mult_class.Setprod" (999)
  logic = "\<Prod>" pttrn[0] "\<in>" logic[51] "." any[10] => "_setprod" (10)
  logic = "\<Prod>" pttrn[0] "|" logic[0] "." any[10] => "_qsetprod" (10)
  logic = "\<Prod>" idt[0] "\<le>" any[0] "." any[10] => "_upto_setprod" (10)
  logic = "\<Prod>" idt[0] "<" any[0] "." any[10] => "_upt_setprod" (10)
  logic = "\<Prod>" idt[0] "=" any[0] "..<" any[0] "." any[10] => "_from_upto_setprod" (10)
  logic = "\<Prod>" idt[0] "=" any[0] ".." any[0] "." any[10] => "_from_to_setprod" (10)
  logic = "\<Prod>" pttrn[0] "\<leftarrow>" logic[51] "." any[10] => "_listprod" (10)
  logic = "PROD" pttrn[0] ":" logic[51] "." any[10] => "_setprod" (10)
  logic = "PROD" pttrn[0] "|" logic[0] "." any[10] => "_qsetprod" (10)
  logic = "PROD" idt[0] "<=" any[0] "." any[10] => "_upto_setprod" (10)
  logic = "PROD" idt[0] "<" any[0] "." any[10] => "_upt_setprod" (10)
  logic = "PROD" idt[0] "=" any[0] "..<" any[0] "." any[10] => "_from_upto_setprod" (10)
  logic = "PROD" idt[0] "=" any[0] ".." any[0] "." any[10] => "_from_to_setprod" (10)
  logic = "PROD" pttrn[0] "<-" logic[51] "." any[10] => "_listprod" (10)
  logic = "\<int>" => "\<^const>Int.ring_1_class.Ints" (1000)
  logic = "\<Sqinter>\<^sub>f\<^sub>i\<^sub>n" logic[900] => "\<^const>Lattices_Big.semilattice_inf_class.Inf_fin" (900)
  logic = "\<Squnion>\<^sub>f\<^sub>i\<^sub>n" logic[900] => "\<^const>Lattices_Big.semilattice_sup_class.Sup_fin" (900)
  logic = "{..<" any[0] "}" => "\<^const>Set_Interval.ord_class.lessThan" (1000)
  logic = "{.." any[0] "}" => "\<^const>Set_Interval.ord_class.atMost" (1000)
  logic = "[]" => "\<^const>List.list.Nil" (1000)
  logic = "[" args[0] "]" => "_list" (1000)
  logic = "[" pttrn[0] "<-" logic[0] "." logic[0] "]" => "_filter" (1000)
  logic = "[" pttrn[0] "\<leftarrow>" logic[0] "." logic[0] "]" => "_filter" (1000)
  logic = "[" logic[0] "..<" logic[0] "]" => "\<^const>List.upt" (1000)
  logic = "[" any[0] "." List.lc_qual[0] List.lc_quals[0] => "_listcompr" (1000)
  logic = "[" logic[0] ".." logic[0] "]" => "\<^const>List.upto" (1000)
  logic = "[" Map.maplets[0] "]" => "_Map" (1000)
  logic = "CHR" str_position[0] => "_Char" (1000)
  logic = str_position[0] => "_String" (1000)
  logic = "TYPEREP" "(" type[0] ")" => "_TYPEREP" (1000)
  logic = "\<lparr>" Record.fields[0] "," "\<dots>" "=" any[0] "\<rparr>" => "_record_scheme" (1000)
  logic = "\<lparr>" Record.fields[0] "\<rparr>" => "_record" (1000)
  logic = "(|" Record.fields[0] "," "..." "=" any[0] "|)" => "_record_scheme" (1000)
  logic = "(|" Record.fields[0] "|)" => "_record" (1000)
  logic = "\<forall>\<^sub>F" pttrn[0] "in" logic[0] "." logic[10] => "_eventually" (10)
  logic = "\<exists>\<^sub>F" pttrn[0] "in" logic[0] "." logic[10] => "_frequently" (10)
  logic = "\<exists>\<^sub>\<infinity>" idts[0] "." logic[10] => "\<^const>Filter.Inf_many_binder" (10)
  logic = "\<forall>\<^sub>\<infinity>" idts[0] "." logic[10] => "\<^const>Filter.Alm_all_binder" (10)
  logic = "MOST" idts[0] "." logic[10] => "\<^const>Filter.Alm_all_binder" (10)
  logic = "INFM" idts[0] "." logic[10] => "\<^const>Filter.Inf_many_binder" (10)
  logic = "LIM" pttrns[1000] any[10] "." any[0] ":>" any[10] => "_LIM" (10)
  logic = "\<rat>" => "\<^const>Rat.field_char_0_class.Rats" (1000)
  logic = float_const[0] => "_Float" (1000)
  logic = "at" any[1000] "within" logic[60] => "\<^const>Topological_Spaces.topological_space_class.at_within" (60)
  logic = "at" => "\<^const>Topological_Spaces.topological_space_class.at" (1000)
  logic = "\<real>" => "\<^const>Real_Vector_Spaces.Reals" (1000)
  logic = "FDERIV" logic[1000] any[1000] ":>" logic[60] => "\<^const>Deriv.FDERIV" (60)
  logic = "DERIV" logic[1000] any[1000] ":>" any[60] => "\<^const>Deriv.DERIV" (60)
  logic = "\<lfloor>" any[0] "\<rfloor>" => "\<^const>Option.option.Some" (1000)
  logic = "\<lceil>" logic[0] "\<rceil>" => "\<^const>UML_Types.drop" (1000)
  logic = "I\<lbrakk>" any[0] "\<rbrakk>" => "\<^const>UML_Types.Sem" (1000)
  logic = "\<upsilon>" logic[100] => "\<^const>UML_Logic.valid" (100)
  logic = "\<delta>" logic[100] => "\<^const>UML_Logic.defined" (100)
  logic = "not" => "\<^const>UML_Logic.OclNot" (1000)
  logic = "\<bottom>" => "\<^const>UML_Types.bot_class.bot" (1000)
  logic = "\<bottom>" => "\<^const>Option.option.None" (1000)
  logic = "Pair{" logic[0] "," logic[0] "}" => "\<^const>UML_Pair.OclPair" (1000)
  logic = "\<zero>" => "\<^const>UML_Integer.OclInt0" (1000)
  logic = "\<one>" => "\<^const>UML_Integer.OclInt1" (1000)
  logic = "\<two>" => "\<^const>UML_Integer.OclInt2" (1000)
  logic = "\<three>" => "\<^const>UML_Integer.OclInt3" (1000)
  logic = "\<four>" => "\<^const>UML_Integer.OclInt4" (1000)
  logic = "\<five>" => "\<^const>UML_Integer.OclInt5" (1000)
  logic = "\<six>" => "\<^const>UML_Integer.OclInt6" (1000)
  logic = "\<seven>" => "\<^const>UML_Integer.OclInt7" (1000)
  logic = "\<eight>" => "\<^const>UML_Integer.OclInt8" (1000)
  logic = "\<nine>" => "\<^const>UML_Integer.OclInt9" (1000)
  logic = "\<one>\<zero>" => "\<^const>UML_Integer.OclInt10" (1000)
  logic = "\<a>" => "\<^const>UML_String.OclStringa" (1000)
  logic = "\<b>" => "\<^const>UML_String.OclStringb" (1000)
  logic = "\<c>" => "\<^const>UML_String.OclStringc" (1000)
  logic = "\<zero>.\<zero>" => "\<^const>UML_Real.OclReal0" (1000)
  logic = "\<one>.\<zero>" => "\<^const>UML_Real.OclReal1" (1000)
  logic = "\<two>.\<zero>" => "\<^const>UML_Real.OclReal2" (1000)
  logic = "\<three>.\<zero>" => "\<^const>UML_Real.OclReal3" (1000)
  logic = "\<four>.\<zero>" => "\<^const>UML_Real.OclReal4" (1000)
  logic = "\<five>.\<zero>" => "\<^const>UML_Real.OclReal5" (1000)
  logic = "\<six>.\<zero>" => "\<^const>UML_Real.OclReal6" (1000)
  logic = "\<seven>.\<zero>" => "\<^const>UML_Real.OclReal7" (1000)
  logic = "\<eight>.\<zero>" => "\<^const>UML_Real.OclReal8" (1000)
  logic = "\<nine>.\<zero>" => "\<^const>UML_Real.OclReal9" (1000)
  logic = "\<one>\<zero>.\<zero>" => "\<^const>UML_Real.OclReal10" (1000)
  logic = "\<pi>" => "\<^const>UML_Real.OclRealpi" (1000)
  logic = "Bag{}" => "\<^const>UML_Bag.mtBag" (1000)
  logic = "Bag{" args[0] "}" => "_OclFinbag" (1000)
  logic = "Set{}" => "\<^const>UML_Set.mtSet" (1000)
  logic = "Set{" args[0] "}" => "_OclFinset" (1000)
  logic = "Sequence{}" => "\<^const>UML_Sequence.mtSequence" (1000)
  logic = "Sequence{" args[0] "}" => "_OclFinsequence" (1000)
  logic = cartouche_position[0] => "_cartouche_oclstring" (1000)
  logic = "_'" => "_ocl_denotation" (1000)
  logic = logic[0] "->asBag\<^sub>P\<^sub>a\<^sub>i\<^sub>r()" => "\<^const>UML_Library.OclAsBag\<^sub>P\<^sub>a\<^sub>i\<^sub>r" (1000)
  logic = logic[0] "->asBag\<^sub>S\<^sub>e\<^sub>t()" => "\<^const>UML_Library.OclAsBag\<^sub>S\<^sub>e\<^sub>t" (1000)
  logic = logic[0] "->asBag\<^sub>S\<^sub>e\<^sub>q()" => "\<^const>UML_Library.OclAsBag\<^sub>S\<^sub>e\<^sub>q" (1000)
  logic = logic[0] "->asSequence\<^sub>P\<^sub>a\<^sub>i\<^sub>r()" => "\<^const>UML_Library.OclAsSeq\<^sub>P\<^sub>a\<^sub>i\<^sub>r" (1000)
  logic = logic[0] "->asSequence\<^sub>B\<^sub>a\<^sub>g()" => "\<^const>UML_Library.OclAsSeq\<^sub>B\<^sub>a\<^sub>g" (1000)
  logic = logic[0] "->asSequence\<^sub>S\<^sub>e\<^sub>t()" => "\<^const>UML_Library.OclAsSeq\<^sub>S\<^sub>e\<^sub>t" (1000)
  logic = logic[0] "->asSet\<^sub>B\<^sub>a\<^sub>g()" => "\<^const>UML_Library.OclAsSet\<^sub>B\<^sub>a\<^sub>g" (1000)
  logic = logic[0] "->asSet\<^sub>P\<^sub>a\<^sub>i\<^sub>r()" => "\<^const>UML_Library.OclAsSet\<^sub>P\<^sub>a\<^sub>i\<^sub>r" (1000)
  logic = logic[0] "->asSet\<^sub>S\<^sub>e\<^sub>q()" => "\<^const>UML_Library.OclAsSet\<^sub>S\<^sub>e\<^sub>q" (1000)
  logic = logic[0] "->asPair\<^sub>B\<^sub>a\<^sub>g()" => "\<^const>UML_Library.OclAsPair\<^sub>B\<^sub>a\<^sub>g" (1000)
  logic = logic[0] "->asPair\<^sub>S\<^sub>e\<^sub>t()" => "\<^const>UML_Library.OclAsPair\<^sub>S\<^sub>e\<^sub>t" (1000)
  logic = logic[0] "->asPair\<^sub>S\<^sub>e\<^sub>q()" => "\<^const>UML_Library.OclAsPair\<^sub>S\<^sub>e\<^sub>q" (1000)
  logic = logic[0] "->oclAsType\<^sub>I\<^sub>n\<^sub>t(Real)" => "\<^const>UML_Library.OclAsReal\<^sub>I\<^sub>n\<^sub>t" (1000)
  logic = logic[0] "->oclAsType\<^sub>R\<^sub>e\<^sub>a\<^sub>l(Integer)" => "\<^const>UML_Library.OclAsInteger\<^sub>R\<^sub>e\<^sub>a\<^sub>l" (1000)
  logic = logic[0] "->oclAsType\<^sub>R\<^sub>e\<^sub>a\<^sub>l(Boolean)" => "\<^const>UML_Library.OclAsBoolean\<^sub>R\<^sub>e\<^sub>a\<^sub>l" (1000)
  logic = logic[0] "->oclAsType\<^sub>I\<^sub>n\<^sub>t(Boolean)" => "\<^const>UML_Library.OclAsBoolean\<^sub>I\<^sub>n\<^sub>t" (1000)
  logic = logic[0] "->sum\<^sub>S\<^sub>e\<^sub>q()" => "\<^const>UML_Sequence.OclSum" (1000)
  logic = logic[0] "->count\<^sub>S\<^sub>e\<^sub>q(" logic[0] ")" => "\<^const>UML_Sequence.OclCount" (1000)
  logic = logic[0] "->any\<^sub>S\<^sub>e\<^sub>q()" => "\<^const>UML_Sequence.OclANY" (1000)
  logic = logic[0] "->notEmpty\<^sub>S\<^sub>e\<^sub>q()" => "\<^const>UML_Sequence.OclNotEmpty" (1000)
  logic = logic[0] "->isEmpty\<^sub>S\<^sub>e\<^sub>q()" => "\<^const>UML_Sequence.OclIsEmpty" (1000)
  logic = logic[0] "->size\<^sub>S\<^sub>e\<^sub>q()" => "\<^const>UML_Sequence.OclSize" (1000)
  logic = logic[0] "->select\<^sub>S\<^sub>e\<^sub>q(" id "|" logic[0] ")" => "_OclSelectSeq" (1000)
  logic = logic[0] "->collect\<^sub>S\<^sub>e\<^sub>q(" id "|" logic[0] ")" => "_OclCollectSeq" (1000)
  logic = logic[0] "->exists\<^sub>S\<^sub>e\<^sub>q(" id "|" logic[0] ")" => "_OclExistSeq" (1000)
  logic = logic[0] "->forAll\<^sub>S\<^sub>e\<^sub>q(" id "|" logic[0] ")" => "_OclForallSeq" (1000)
  logic = logic[0] "->iterate\<^sub>S\<^sub>e\<^sub>q(" idt[0] ";" idt[0] "=" any[0] "|" any[0] ")" => "_OclIterateSeq" (1000)
  logic = logic[0] "->last\<^sub>S\<^sub>e\<^sub>q(" logic[0] ")" => "\<^const>UML_Sequence.OclLast" (1000)
  logic = logic[0] "->first\<^sub>S\<^sub>e\<^sub>q(" logic[0] ")" => "\<^const>UML_Sequence.OclFirst" (1000)
  logic = logic[0] "->at\<^sub>S\<^sub>e\<^sub>q(" logic[0] ")" => "\<^const>UML_Sequence.OclAt" (1000)
  logic = logic[0] "->union\<^sub>S\<^sub>e\<^sub>q(" logic[0] ")" => "\<^const>UML_Sequence.OclUnion" (1000)
  logic = logic[0] "->append\<^sub>S\<^sub>e\<^sub>q(" logic[0] ")" => "\<^const>UML_Sequence.OclAppend" (1000)
  logic = logic[0] "->excluding\<^sub>S\<^sub>e\<^sub>q(" logic[0] ")" => "\<^const>UML_Sequence.OclExcluding" (1000)
  logic = logic[0] "->including\<^sub>S\<^sub>e\<^sub>q(" logic[0] ")" => "\<^const>UML_Sequence.OclIncluding" (1000)
  logic = logic[0] "->prepend\<^sub>S\<^sub>e\<^sub>q(" logic[0] ")" => "\<^const>UML_Sequence.OclPrepend" (1000)
  logic = logic[0] "->sum\<^sub>S\<^sub>e\<^sub>t()" => "\<^const>UML_Set.OclSum" (1000)
  logic = logic[0] "->count\<^sub>S\<^sub>e\<^sub>t(" logic[0] ")" => "\<^const>UML_Set.OclCount" (1000)
  logic = logic[0] "->intersection\<^sub>S\<^sub>e\<^sub>t(" logic[0] ")" => "\<^const>UML_Set.OclIntersection" (1000)
  logic = logic[0] "->union\<^sub>S\<^sub>e\<^sub>t(" logic[0] ")" => "\<^const>UML_Set.OclUnion" (1000)
  logic = logic[0] "->excludesAll\<^sub>S\<^sub>e\<^sub>t(" logic[0] ")" => "\<^const>UML_Set.OclExcludesAll" (1000)
  logic = logic[0] "->includesAll\<^sub>S\<^sub>e\<^sub>t(" logic[0] ")" => "\<^const>UML_Set.OclIncludesAll" (1000)
  logic = logic[0] "->reject\<^sub>S\<^sub>e\<^sub>t(" id "|" logic[0] ")" => "_OclRejectSet" (1000)
  logic = logic[0] "->select\<^sub>S\<^sub>e\<^sub>t(" id "|" logic[0] ")" => "_OclSelectSet" (1000)
  logic = logic[0] "->iterate\<^sub>S\<^sub>e\<^sub>t(" idt[0] ";" idt[0] "=" any[0] "|" any[0] ")" => "_OclIterateSet" (1000)
  logic = logic[0] "->exists\<^sub>S\<^sub>e\<^sub>t(" id "|" logic[0] ")" => "_OclExistSet" (1000)
  logic = logic[0] "->forAll\<^sub>S\<^sub>e\<^sub>t(" id "|" logic[0] ")" => "_OclForallSet" (1000)
  logic = logic[0] "->any\<^sub>S\<^sub>e\<^sub>t()" => "\<^const>UML_Set.OclANY" (1000)
  logic = logic[0] "->notEmpty\<^sub>S\<^sub>e\<^sub>t()" => "\<^const>UML_Set.OclNotEmpty" (1000)
  logic = logic[0] "->isEmpty\<^sub>S\<^sub>e\<^sub>t()" => "\<^const>UML_Set.OclIsEmpty" (1000)
  logic = logic[0] "->size\<^sub>S\<^sub>e\<^sub>t()" => "\<^const>UML_Set.OclSize" (1000)
  logic = logic[0] "->excludes\<^sub>S\<^sub>e\<^sub>t(" logic[0] ")" => "\<^const>UML_Set.OclExcludes" (1000)
  logic = logic[0] "->includes\<^sub>S\<^sub>e\<^sub>t(" logic[0] ")" => "\<^const>UML_Set.OclIncludes" (1000)
  logic = logic[0] "->excluding\<^sub>S\<^sub>e\<^sub>t(" logic[0] ")" => "\<^const>UML_Set.OclExcluding" (1000)
  logic = logic[0] "->including\<^sub>S\<^sub>e\<^sub>t(" logic[0] ")" => "\<^const>UML_Set.OclIncluding" (1000)
  logic = logic[0] "->sum\<^sub>B\<^sub>a\<^sub>g()" => "\<^const>UML_Bag.OclSum" (1000)
  logic = logic[0] "->count\<^sub>B\<^sub>a\<^sub>g(" logic[0] ")" => "\<^const>UML_Bag.OclCount" (1000)
  logic = logic[0] "->intersection\<^sub>B\<^sub>a\<^sub>g(" logic[0] ")" => "\<^const>UML_Bag.OclIntersection" (1000)
  logic = logic[0] "->union\<^sub>B\<^sub>a\<^sub>g(" logic[0] ")" => "\<^const>UML_Bag.OclUnion" (1000)
  logic = logic[0] "->excludesAll\<^sub>B\<^sub>a\<^sub>g(" logic[0] ")" => "\<^const>UML_Bag.OclExcludesAll" (1000)
  logic = logic[0] "->includesAll\<^sub>B\<^sub>a\<^sub>g(" logic[0] ")" => "\<^const>UML_Bag.OclIncludesAll" (1000)
  logic = logic[0] "->reject\<^sub>B\<^sub>a\<^sub>g(" id "|" logic[0] ")" => "_OclRejectBag" (1000)
  logic = logic[0] "->select\<^sub>B\<^sub>a\<^sub>g(" id "|" logic[0] ")" => "_OclSelectBag" (1000)
  logic = logic[0] "->iterate\<^sub>B\<^sub>a\<^sub>g(" idt[0] ";" idt[0] "=" any[0] "|" any[0] ")" => "_OclIterateBag" (1000)
  logic = logic[0] "->exists\<^sub>B\<^sub>a\<^sub>g(" id "|" logic[0] ")" => "_OclExistBag" (1000)
  logic = logic[0] "->forAll\<^sub>B\<^sub>a\<^sub>g(" id "|" logic[0] ")" => "_OclForallBag" (1000)
  logic = logic[0] "->any\<^sub>B\<^sub>a\<^sub>g()" => "\<^const>UML_Bag.OclANY" (1000)
  logic = logic[0] "->notEmpty\<^sub>B\<^sub>a\<^sub>g()" => "\<^const>UML_Bag.OclNotEmpty" (1000)
  logic = logic[0] "->isEmpty\<^sub>B\<^sub>a\<^sub>g()" => "\<^const>UML_Bag.OclIsEmpty" (1000)
  logic = logic[0] "->size\<^sub>B\<^sub>a\<^sub>g()" => "\<^const>UML_Bag.OclSize" (1000)
  logic = logic[0] "->excludes\<^sub>B\<^sub>a\<^sub>g(" logic[0] ")" => "\<^const>UML_Bag.OclExcludes" (1000)
  logic = logic[0] "->includes\<^sub>B\<^sub>a\<^sub>g(" logic[0] ")" => "\<^const>UML_Bag.OclIncludes" (1000)
  logic = logic[0] "->excluding\<^sub>B\<^sub>a\<^sub>g(" logic[0] ")" => "\<^const>UML_Bag.OclExcluding" (1000)
  logic = logic[0] "->including\<^sub>B\<^sub>a\<^sub>g(" logic[0] ")" => "\<^const>UML_Bag.OclIncluding" (1000)
  logic = logic[30] "\<cong>" logic[31] => "\<^const>UML_Bag.ApproxEq" (30)
  logic = logic[36] "\<le>\<^sub>r\<^sub>e\<^sub>a\<^sub>l" logic[36] => "\<^const>UML_Real.OclLe\<^sub>R\<^sub>e\<^sub>a\<^sub>l" (35)
  logic = logic[36] "<\<^sub>r\<^sub>e\<^sub>a\<^sub>l" logic[36] => "\<^const>UML_Real.OclLess\<^sub>R\<^sub>e\<^sub>a\<^sub>l" (35)
  logic = logic[46] "mod\<^sub>r\<^sub>e\<^sub>a\<^sub>l" logic[46] => "\<^const>UML_Real.OclModulus\<^sub>R\<^sub>e\<^sub>a\<^sub>l" (45)
  logic = logic[46] "div\<^sub>r\<^sub>e\<^sub>a\<^sub>l" logic[46] => "\<^const>UML_Real.OclDivision\<^sub>R\<^sub>e\<^sub>a\<^sub>l" (45)
  logic = logic[46] "*\<^sub>r\<^sub>e\<^sub>a\<^sub>l" logic[46] => "\<^const>UML_Real.OclMult\<^sub>R\<^sub>e\<^sub>a\<^sub>l" (45)
  logic = logic[42] "-\<^sub>r\<^sub>e\<^sub>a\<^sub>l" logic[42] => "\<^const>UML_Real.OclMinus\<^sub>R\<^sub>e\<^sub>a\<^sub>l" (41)
  logic = logic[41] "+\<^sub>r\<^sub>e\<^sub>a\<^sub>l" logic[41] => "\<^const>UML_Real.OclAdd\<^sub>R\<^sub>e\<^sub>a\<^sub>l" (40)
  logic = logic[41] "+\<^sub>s\<^sub>t\<^sub>r\<^sub>i\<^sub>n\<^sub>g" logic[41] => "\<^const>UML_String.OclAdd\<^sub>S\<^sub>t\<^sub>r\<^sub>i\<^sub>n\<^sub>g" (40)
  logic = logic[36] "\<le>\<^sub>i\<^sub>n\<^sub>t" logic[36] => "\<^const>UML_Integer.OclLe\<^sub>I\<^sub>n\<^sub>t\<^sub>e\<^sub>g\<^sub>e\<^sub>r" (35)
  logic = logic[36] "<\<^sub>i\<^sub>n\<^sub>t" logic[36] => "\<^const>UML_Integer.OclLess\<^sub>I\<^sub>n\<^sub>t\<^sub>e\<^sub>g\<^sub>e\<^sub>r" (35)
  logic = logic[46] "mod\<^sub>i\<^sub>n\<^sub>t" logic[46] => "\<^const>UML_Integer.OclModulus\<^sub>I\<^sub>n\<^sub>t\<^sub>e\<^sub>g\<^sub>e\<^sub>r" (45)
  logic = logic[46] "div\<^sub>i\<^sub>n\<^sub>t" logic[46] => "\<^const>UML_Integer.OclDivision\<^sub>I\<^sub>n\<^sub>t\<^sub>e\<^sub>g\<^sub>e\<^sub>r" (45)
  logic = logic[46] "*\<^sub>i\<^sub>n\<^sub>t" logic[46] => "\<^const>UML_Integer.OclMult\<^sub>I\<^sub>n\<^sub>t\<^sub>e\<^sub>g\<^sub>e\<^sub>r" (45)
  logic = logic[42] "-\<^sub>i\<^sub>n\<^sub>t" logic[42] => "\<^const>UML_Integer.OclMinus\<^sub>I\<^sub>n\<^sub>t\<^sub>e\<^sub>g\<^sub>e\<^sub>r" (41)
  logic = logic[41] "+\<^sub>i\<^sub>n\<^sub>t" logic[41] => "\<^const>UML_Integer.OclAdd\<^sub>I\<^sub>n\<^sub>t\<^sub>e\<^sub>g\<^sub>e\<^sub>r" (40)
  logic = logic[0] ".Second()" => "\<^const>UML_Pair.OclSecond" (1000)
  logic = logic[0] ".First()" => "\<^const>UML_Pair.OclFirst" (1000)
  logic = logic[41] "<>" logic[41] => "_notequal" (40)
  logic = logic[30] "\<doteq>" logic[31] => "\<^const>UML_Logic.StrictRefEq" (30)
  logic = logic[0] "\<Turnstile>\<^sub>p\<^sub>o\<^sub>s\<^sub>t" logic[0] => "\<^const>UML_Logic.OclValid_at_post" (50)
  logic = logic[0] "\<Turnstile>\<^sub>p\<^sub>r\<^sub>e" logic[0] => "\<^const>UML_Logic.OclValid_at_pre" (50)
  logic = logic[0] "|\<noteq>" logic[0] => "_OclNonValid" (50)
  logic = logic[0] "\<Turnstile>" logic[0] => "\<^const>UML_Logic.OclValid" (50)
  logic = logic[25] "implies" logic[26] => "\<^const>UML_Logic.OclImplies" (25)
  logic = logic[25] "or" logic[26] => "\<^const>UML_Logic.OclOr" (25)
  logic = logic[30] "and" logic[31] => "\<^const>UML_Logic.OclAnd" (30)
  logic = logic[30] "\<triangleq>\<^sub>p\<^sub>o\<^sub>s\<^sub>t" logic[31] => "\<^const>UML_Logic.StrongEq\<^sub>p\<^sub>o\<^sub>s\<^sub>t" (30)
  logic = logic[30] "\<triangleq>\<^sub>p\<^sub>r\<^sub>e" logic[31] => "\<^const>UML_Logic.StrongEq\<^sub>p\<^sub>r\<^sub>e" (30)
  logic = logic[30] "\<triangleq>" logic[31] => "\<^const>UML_Logic.StrongEq" (30)
  logic = logic[65] "choose" logic[66] => "\<^const>Binomial.binomial" (65)
  logic = logic[51] "has_real_derivative" logic[51] => "\<^const>Deriv.has_real_derivative" (50)
  logic = logic[51] "differentiable" logic[51] => "\<^const>Deriv.differentiable" (50)
  logic = logic[51] "has_vector_derivative" any[51] => "\<^const>Deriv.has_vector_derivative" (50)
  logic = logic[51] "has_field_derivative" any[51] => "\<^const>Deriv.has_field_derivative" (50)
  logic = logic[51] "has_derivative" logic[51] => "\<^const>Deriv.has_derivative" (50)
  logic = logic[81] "sums" any[80] => "\<^const>Series.sums" (80)
  logic = logic[76] "*\<^sub>R" any[75] => "\<^const>Real_Vector_Spaces.scaleR_class.scaleR" (75)
  logic = logic[60] "\<midarrow>" any[0] "\<rightarrow>" any[60] => "\<^const>Topological_Spaces.LIM" (60)
  logic = logic[60] "\<longlonglongrightarrow>" any[60] => "\<^const>Topological_Spaces.topological_space_class.LIMSEQ" (60)
  logic = logic[56] "\<longlongrightarrow>" any[55] => "\<^const>Topological_Spaces.topological_space_class.tendsto" (55)
  logic = logic[81] "\<times>\<^sub>F" logic[80] => "\<^const>Filter.prod_filter" (80)
  logic = logic[900] "(" Map.maplets[0] ")" => "_MapUpd" (900)
  logic = logic[51] "\<subseteq>\<^sub>m" logic[51] => "\<^const>Map.map_le" (50)
  logic = logic[110] "|`" logic[111] => "\<^const>Map.restrict_map" (110)
  logic = logic[100] "++" logic[101] => "\<^const>Map.map_add" (100)
  logic = logic[55] "\<circ>\<^sub>m" logic[56] => "\<^const>Map.map_comp" (55)
  logic = logic[100] "!" logic[101] => "\<^const>List.nth" (100)
  logic = logic[66] "@" logic[65] => "\<^const>List.append" (65)
  logic = logic[81] "respects2" logic[80] => "\<^const>Equiv_Relations.RESPECTS2" (80)
  logic = logic[81] "respects" logic[80] => "\<^const>Equiv_Relations.RESPECTS" (80)
  logic = logic[90] "//" logic[91] => "\<^const>Equiv_Relations.quotient" (90)
  logic = logic[56] "initial_segment_of" logic[56] => "\<^const>Zorn.initialSegmentOf" (55)
  logic = logic[81] "<*mlex*>" logic[80] => "\<^const>Wellfounded.mlex_prod" (80)
  logic = logic[81] "<*lex*>" logic[80] => "\<^const>Wellfounded.lex_prod" (80)
  logic = logic[1000] "^*" => "\<^const>Transitive_Closure.rtrancl" (999)
  logic = logic[1000] "^+" => "\<^const>Transitive_Closure.trancl" (999)
  logic = logic[1000] "^=" => "\<^const>Transitive_Closure.reflcl" (999)
  logic = logic[1000] "^**" => "\<^const>Transitive_Closure.rtranclp" (1000)
  logic = logic[1000] "^++" => "\<^const>Transitive_Closure.tranclp" (1000)
  logic = logic[1000] "^==" => "\<^const>Transitive_Closure.reflclp" (1000)
  logic = logic[1000] "\<^sup>=\<^sup>=" => "\<^const>Transitive_Closure.reflclp" (1000)
  logic = logic[1000] "\<^sup>=" => "\<^const>Transitive_Closure.reflcl" (999)
  logic = logic[1000] "\<^sup>*\<^sup>*" => "\<^const>Transitive_Closure.rtranclp" (1000)
  logic = logic[1000] "\<^sup>+\<^sup>+" => "\<^const>Transitive_Closure.tranclp" (1000)
  logic = logic[1000] "\<^sup>+" => "\<^const>Transitive_Closure.trancl" (999)
  logic = logic[1000] "\<^sup>*" => "\<^const>Transitive_Closure.rtrancl" (999)
  logic = logic[91] "``" logic[90] => "\<^const>Relation.Image" (90)
  logic = logic[1000] "^-1" => "\<^const>Relation.converse" (999)
  logic = logic[1000] "^--1" => "\<^const>Relation.conversep" (1000)
  logic = logic[1000] "\<inverse>\<inverse>" => "\<^const>Relation.conversep" (1000)
  logic = logic[1000] "\<inverse>" => "\<^const>Relation.converse" (999)
  logic = logic[76] "OO" logic[75] => "\<^const>Relation.relcompp" (75)
  logic = logic[76] "O" logic[75] => "\<^const>Relation.relcomp" (75)
  logic = logic[66] "<+>" logic[65] => "\<^const>Sum_Type.Plus" (65)
  logic = logic[81] "\<times>" logic[80] => "\<^const>Product_Type.Times" (80)
  logic = logic[55] "o" logic[56] => "\<^const>Fun.comp" (55)
  logic = logic[55] "\<circ>" logic[56] => "\<^const>Fun.comp" (55)
  logic = logic[91] "-`" logic[90] => "\<^const>Set.vimage" (90)
  logic = logic[91] "`" logic[90] => "\<^const>Set.image" (90)
  logic = logic[65] "Un" logic[66] => "\<^const>Set.union" (65)
  logic = logic[65] "\<union>" logic[66] => "\<^const>Set.union" (65)
  logic = logic[70] "Int" logic[71] => "\<^const>Set.inter" (70)
  logic = logic[70] "\<inter>" logic[71] => "\<^const>Set.inter" (70)
  logic = logic[51] "\<supset>" logic[51] => "\<^const>Set.supset" (50)
  logic = logic[51] "\<supseteq>" logic[51] => "\<^const>Set.supset_eq" (50)
  logic = logic[51] "\<subset>" logic[51] => "\<^const>Set.subset" (50)
  logic = logic[51] "\<subseteq>" logic[51] => "\<^const>Set.subset_eq" (50)
  logic = logic[26] "\<longleftrightarrow>" logic[25] => "\<^const>HOL.iff" (25)
  logic = logic[36] "&" logic[35] => "\<^const>HOL.conj" (35)
  logic = logic[31] "|" logic[30] => "\<^const>HOL.disj" (30)
  logic = logic[26] "-->" logic[25] => "\<^const>HOL.implies" (25)
  logic = logic[31] "\<or>" logic[30] => "\<^const>HOL.disj" (30)
  logic = logic[36] "\<and>" logic[35] => "\<^const>HOL.conj" (35)
  logic = logic[26] "\<longrightarrow>" logic[25] => "\<^const>HOL.implies" (25)
  logic = logic[1000] cargs[1000] => "_applC" (999)
  logic = logic[4] "::" type[0] => "_constrain" (3)
  logic = any[81] "powr" any[80] => "\<^const>Transcendental.powr" (80)
  logic = any[65] "gchoose" logic[66] => "\<^const>Binomial.field_char_0_class.gbinomial" (65)
  logic = any[70] "/\<^sub>R" logic[71] => "\<^const>Real_Vector_Spaces.scaleR_class.divideR" (70)
  logic = any[900] "(|" Record.field_updates[0] "|)" => "_record_update" (900)
  logic = any[900] "\<lparr>" Record.field_updates[0] "\<rparr>" => "_record_update" (900)
  logic = any[900] "[" List.lupdbinds[0] "]" => "_LUpdate" (900)
  logic = any[66] "#" logic[65] => "\<^const>List.list.Cons" (65)
  logic = any[70] "mod" any[71] => "\<^const>Divides.div_class.mod" (70)
  logic = any[1000] "\<^sup>2" => "\<^const>Power.power_class.power2" (999)
  logic = any[81] "^" logic[80] => "\<^const>Power.power_class.power" (80)
  logic = any[81] "^^" logic[80] => "\<^const>Nat.compower" (80)
  logic = any[70] "/" any[71] => "\<^const>Fields.inverse_class.inverse_divide" (70)
  logic = any[70] "div" any[71] => "\<^const>Rings.divide_class.divide" (70)
  logic = any[51] "dvd" any[51] => "\<^const>Rings.dvd_class.dvd" (50)
  logic = any[1000] "(" Fun.updbinds[0] ")" => "_Update" (900)
  logic = any[51] ":" logic[51] => "\<^const>Set.member" (50)
  logic = any[51] "~:" logic[51] => "\<^const>Set.not_member" (50)
  logic = any[51] "\<notin>" logic[51] => "\<^const>Set.not_member" (50)
  logic = any[51] "\<in>" logic[51] => "\<^const>Set.member" (50)
  logic = any[70] "*" any[71] => "\<^const>Groups.times_class.times" (70)
  logic = any[65] "-" any[66] => "\<^const>Groups.minus_class.minus" (65)
  logic = any[65] "+" any[66] => "\<^const>Groups.plus_class.plus" (65)
  logic = any[51] ">=" any[51] => "\<^const>Orderings.ord_class.greater_eq" (50)
  logic = any[51] "<=" any[51] => "\<^const>Orderings.ord_class.less_eq" (50)
  logic = any[51] ">" any[51] => "\<^const>Orderings.ord_class.greater" (50)
  logic = any[51] "\<ge>" any[51] => "\<^const>Orderings.ord_class.greater_eq" (50)
  logic = any[51] "\<le>" any[51] => "\<^const>Orderings.ord_class.less_eq" (50)
  logic = any[51] "<" any[51] => "\<^const>Orderings.ord_class.less" (50)
  logic = any[50] "~=" any[51] => "\<^const>HOL.not_equal" (50)
  logic = any[50] "\<noteq>" any[51] => "\<^const>HOL.not_equal" (50)
  logic = any[50] "=" any[51] => "\<^const>HOL.eq" (50)
  logic = logic[0] ".allInstances()" => "\<^const>UML_State.OclAllInstances_at_post" (1000)
  logic = logic[0] ".allInstances@pre()" => "\<^const>UML_State.OclAllInstances_at_pre" (1000)
  logic = logic[0] ".oclIsNew()" => "\<^const>UML_State.OclIsNew" (1000)
  logic = logic[0] ".oclIsDeleted()" => "\<^const>UML_State.OclIsDeleted" (1000)
  logic = logic[0] ".oclIsMaintained()" => "\<^const>UML_State.OclIsMaintained" (1000)
  logic = logic[0] ".oclIsAbsent()" => "\<^const>UML_State.OclIsAbsent" (1000)
  logic = logic[0] "->oclIsModifiedOnly()" => "\<^const>UML_State.OclIsModifiedOnly" (1000)
  logic = logic[0] "@pre" logic[0] => "\<^const>UML_State.OclSelf_at_pre" (1000)
  logic = logic[0] "@post" logic[0] => "\<^const>UML_State.OclSelf_at_post" (1000)
  logic = var_position[-1] (-1)
  logic = longid_position[-1] (-1)
  logic = id_position[-1] (-1)
  longid_position = longid => "_position" (1000)
  num_const = num_position[0] => "_constify" (1000)
  num_position = num_token => "_position" (1000)
  "prop" = logic[0] => "\<^const>HOL.Trueprop" (5)
  "prop" = prop'[-1] (-1)
  prop' = "TERM" logic[0] => "\<^const>Pure.term" (1000)
  prop' = "SORT_CONSTRAINT" "(" type[0] ")" => "_sort_constraint" (1000)
  prop' = "OFCLASS" "(" type[0] "," logic[0] ")" => "_ofclass" (1000)
  prop' = "\<lbrakk>" asms[0] "\<rbrakk>" "\<Longrightarrow>" "prop"[1] => "_bigimpl" (1)
  prop' = "PROP" aprop[0] => "_aprop" (1000)
  prop' = "(" prop'[0] ")" (1000)
  prop' = "[|" asms[0] "|]" "==>" "prop"[1] => "_bigimpl" (1)
  prop' = "!!" idts[0] "." "prop"[0] => "\<^const>Pure.all_binder" (0)
  prop' = "\<And>" idts[0] "." "prop"[0] => "\<^const>Pure.all_binder" (0)
  prop' = any[3] "\<equiv>" any[3] => "\<^const>Pure.eq" (2)
  prop' = any[3] "==" any[3] => "\<^const>Pure.eq" (2)
  prop' = "prop"[2] "\<Longrightarrow>" "prop"[1] => "\<^const>Pure.imp" (1)
  prop' = "prop"[2] "==>" "prop"[1] => "\<^const>Pure.imp" (1)
  prop' = "prop"[3] "&&&" "prop"[2] => "\<^const>Pure.conjunction" (2)
  prop' = "prop"[2] "=simp=>" "prop"[1] => "\<^const>HOL.simp_implies" (1)
  prop' = prop'[4] "::" type[0] => "_constrain" (3)
  pttrn = "(" pttrn[0] "," Product_Type.patterns[0] ")" => "_pattern" (1000)
  pttrn = idt[-1] (-1)
  pttrns = pttrn[1] pttrns[0] => "_pttrns" (0)
  pttrns = pttrn[-1] (-1)
  sort = "{" classes[0] "}" => "_sort" (1000)
  sort = "{}" => "_topsort" (1000)
  sort = class_name[-1] (-1)
  str_position = str_token => "_position" (1000)
  string_position = string_token => "_position" (1000)
  tid_position = tid => "_position_sort" (1000)
  tvar_position = tvar => "_position_sort" (1000)
  type = "_" => "\<^type>dummy" (1000)
  type = "_" "::" sort[0] => "_dummy_ofsort" (1000)
  type = "(" type[0] ")" (1000)
  type = "(" type[0] "," types[0] ")" type_name[0] => "_tappl" (1000)
  type = "[" types[0] "]" "\<Rightarrow>" type[0] => "_bracket" (0)
  type = "[" types[0] "]" "=>" type[0] => "_bracket" (0)
  type = tvar_position[1000] "::" sort[0] => "_ofsort" (1000)
  type = tid_position[1000] "::" sort[0] => "_ofsort" (1000)
  type = "\<lparr>" Record.field_types[0] "," "\<dots>" "::" type[0] "\<rparr>" => "_record_type_scheme" (1000)
  type = "\<lparr>" Record.field_types[0] "\<rparr>" => "_record_type" (1000)
  type = "(|" Record.field_types[0] "," "..." "::" type[0] "|)" => "_record_type_scheme" (1000)
  type = "(|" Record.field_types[0] "|)" => "_record_type" (1000)
  type = "\<langle>" type[0] "\<rangle>\<^sub>\<bottom>" => "\<^type>Option.option" (1000)
  type = "Pair(" type[0] "," type[0] ")" => "\<^type>UML_Types.Pair\<^sub>b\<^sub>a\<^sub>s\<^sub>e" (1000)
  type = "Set(" type[0] ")" => "\<^type>UML_Types.Set\<^sub>b\<^sub>a\<^sub>s\<^sub>e" (1000)
  type = "Bag(" type[0] ")" => "\<^type>UML_Types.Bag\<^sub>b\<^sub>a\<^sub>s\<^sub>e" (1000)
  type = "Sequence(" type[0] ")" => "\<^type>UML_Types.Sequence\<^sub>b\<^sub>a\<^sub>s\<^sub>e" (1000)
  type = type[1] "\<rightharpoonup>" type[0] => "\<^type>Map.map" (0)
  type = type[11] "+" type[10] => "\<^type>Sum_Type.sum" (10)
  type = type[21] "*" type[20] => "\<^type>Product_Type.prod" (20)
  type = type[21] "\<times>" type[20] => "\<^type>Product_Type.prod" (20)
  type = type[1] "=>" type[0] => "\<^type>fun" (0)
  type = type[1000] type_name[0] => "_tapp" (1000)
  type = type[1] "\<Rightarrow>" type[0] => "\<^type>fun" (0)
  type = type_name[-1] (-1)
  type = tvar_position[-1] (-1)
  type = tid_position[-1] (-1)
  type_name = longid => "_type_name" (1000)
  type_name = id => "_type_name" (1000)
  types = type[0] "," types[0] => "_types" (1000)
  types = type[-1] (-1)
  var_position = var => "_position" (1000)

end
